/* config.c generated by valac 0.22.1, the Vala compiler
 * generated from config.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define YRCD_TYPE_YRCD_CONFIG (yrcd_yrcd_config_get_type ())
#define YRCD_YRCD_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_config))
#define YRCD_YRCD_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_configClass))
#define YRCD_IS_YRCD_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_CONFIG))
#define YRCD_IS_YRCD_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_CONFIG))
#define YRCD_YRCD_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_configClass))

typedef struct _yrcdyrcd_config yrcdyrcd_config;
typedef struct _yrcdyrcd_configClass yrcdyrcd_configClass;
typedef struct _yrcdyrcd_configPrivate yrcdyrcd_configPrivate;
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _yrcdyrcd_config {
	GObject parent_instance;
	yrcdyrcd_configPrivate * priv;
	GList* listen_ports;
	gchar** listen_ips;
	gint listen_ips_length1;
	GList* motd;
	gint ping_invertal;
	gboolean config_error;
	gchar* salt;
};

struct _yrcdyrcd_configClass {
	GObjectClass parent_class;
};

struct _yrcdyrcd_configPrivate {
	GKeyFile* file;
	gchar* _sname;
};


static gpointer yrcd_yrcd_config_parent_class = NULL;

GType yrcd_yrcd_config_get_type (void) G_GNUC_CONST;
#define YRCD_YRCD_CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_configPrivate))
enum  {
	YRCD_YRCD_CONFIG_DUMMY_PROPERTY,
	YRCD_YRCD_CONFIG_SNAME
};
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
yrcdyrcd_config* yrcd_yrcd_config_new (const gchar* filepath);
yrcdyrcd_config* yrcd_yrcd_config_construct (GType object_type, const gchar* filepath);
void yrcd_yrcd_config_set_sname (yrcdyrcd_config* self, const gchar* value);
const gchar* yrcd_yrcd_config_get_sname (yrcdyrcd_config* self);
static void yrcd_yrcd_config_finalize (GObject* obj);
static void _vala_yrcd_yrcd_config_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_yrcd_yrcd_config_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


yrcdyrcd_config* yrcd_yrcd_config_construct (GType object_type, const gchar* filepath) {
	yrcdyrcd_config * self = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filepath != NULL, NULL);
	self = (yrcdyrcd_config*) g_object_new (object_type, NULL);
	{
		GKeyFile* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		GKeyFile* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		GKeyFile* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gint* tmplist = NULL;
		GKeyFile* _tmp7_ = NULL;
		gsize _tmp8_;
		gint* _tmp9_ = NULL;
		gint tmplist_length1 = 0;
		gint _tmplist_size_ = 0;
		gint* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar** _tmp17_ = NULL;
		GKeyFile* _tmp18_ = NULL;
		gsize _tmp19_;
		gchar** _tmp20_ = NULL;
		gint _tmp17__length1 = 0;
		gint __tmp17__size_ = 0;
		gchar* motdpath = NULL;
		GKeyFile* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		GFile* motdfile = NULL;
		const gchar* _tmp23_ = NULL;
		GFile* _tmp24_ = NULL;
		GFileInputStream* _tmp25_ = NULL;
		GFile* _tmp26_ = NULL;
		GFileInputStream* _tmp27_ = NULL;
		GDataInputStream* dis = NULL;
		GFileInputStream* _tmp28_ = NULL;
		GDataInputStream* _tmp29_ = NULL;
		GDataInputStream* _tmp30_ = NULL;
		gchar* motd_line = NULL;
		gint _tmp37_ = 0;
		GKeyFile* _tmp38_ = NULL;
		gint _tmp39_ = 0;
		gchar* _tmp40_ = NULL;
		GKeyFile* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		_tmp0_ = self->priv->file;
		_tmp1_ = filepath;
		g_key_file_load_from_file (_tmp0_, _tmp1_, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp2_ = self->priv->file;
		g_key_file_set_list_separator (_tmp2_, ',');
		_tmp4_ = self->priv->file;
		_tmp5_ = g_key_file_get_string (_tmp4_, "ServerVariables", "server_name", &_inner_error_);
		_tmp3_ = _tmp5_;
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp6_ = _tmp3_;
		yrcd_yrcd_config_set_sname (self, _tmp6_);
		_g_free0 (_tmp6_);
		_tmp7_ = self->priv->file;
		_tmp9_ = g_key_file_get_integer_list (_tmp7_, "Networking", "listening_ports", &_tmp8_, &_inner_error_);
		tmplist = _tmp9_;
		tmplist_length1 = _tmp8_;
		_tmplist_size_ = tmplist_length1;
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp10_ = tmplist;
		_tmp10__length1 = tmplist_length1;
		{
			gint* k_collection = NULL;
			gint k_collection_length1 = 0;
			gint _k_collection_size_ = 0;
			gint k_it = 0;
			k_collection = _tmp10_;
			k_collection_length1 = _tmp10__length1;
			for (k_it = 0; k_it < _tmp10__length1; k_it = k_it + 1) {
				gint k = 0;
				k = k_collection[k_it];
				{
					guint16 j = 0U;
					guint16 _tmp16_ = 0U;
					{
						gboolean _tmp11_ = FALSE;
						j = (guint16) 0;
						_tmp11_ = TRUE;
						while (TRUE) {
							gboolean _tmp12_ = FALSE;
							guint16 _tmp13_ = 0U;
							gint _tmp14_ = 0;
							guint16 _tmp15_ = 0U;
							_tmp12_ = _tmp11_;
							if (!_tmp12_) {
							}
							_tmp11_ = FALSE;
							_tmp13_ = j;
							_tmp14_ = k;
							if (!(((gint) _tmp13_) < _tmp14_)) {
								break;
							}
							_tmp15_ = j;
							j = _tmp15_ + 1;
						}
					}
					_tmp16_ = j;
					self->listen_ports = g_list_append (self->listen_ports, (gpointer) ((guintptr) _tmp16_));
				}
			}
		}
		_tmp18_ = self->priv->file;
		_tmp20_ = g_key_file_get_string_list (_tmp18_, "Networking", "listening_ips", &_tmp19_, &_inner_error_);
		_tmp17_ = _tmp20_;
		_tmp17__length1 = _tmp19_;
		__tmp17__size_ = _tmp17__length1;
		if (_inner_error_ != NULL) {
			tmplist = (g_free (tmplist), NULL);
			goto __catch0_g_error;
		}
		self->listen_ips = (_vala_array_free (self->listen_ips, self->listen_ips_length1, (GDestroyNotify) g_free), NULL);
		self->listen_ips = _tmp17_;
		self->listen_ips_length1 = _tmp17__length1;
		_tmp21_ = self->priv->file;
		_tmp22_ = g_key_file_get_string (_tmp21_, "ServerVariables", "motd_path", &_inner_error_);
		motdpath = _tmp22_;
		if (_inner_error_ != NULL) {
			tmplist = (g_free (tmplist), NULL);
			goto __catch0_g_error;
		}
		_tmp23_ = motdpath;
		_tmp24_ = g_file_new_for_path (_tmp23_);
		motdfile = _tmp24_;
		_tmp26_ = motdfile;
		_tmp27_ = g_file_read (_tmp26_, NULL, &_inner_error_);
		_tmp25_ = _tmp27_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (motdfile);
			_g_free0 (motdpath);
			tmplist = (g_free (tmplist), NULL);
			goto __catch0_g_error;
		}
		_tmp28_ = _tmp25_;
		_tmp29_ = g_data_input_stream_new ((GInputStream*) _tmp28_);
		_tmp30_ = _tmp29_;
		_g_object_unref0 (_tmp28_);
		dis = _tmp30_;
		while (TRUE) {
			gchar* _tmp31_ = NULL;
			GDataInputStream* _tmp32_ = NULL;
			gchar* _tmp33_ = NULL;
			const gchar* _tmp34_ = NULL;
			const gchar* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			_tmp32_ = dis;
			_tmp33_ = g_data_input_stream_read_line (_tmp32_, NULL, NULL, &_inner_error_);
			_tmp31_ = _tmp33_;
			if (_inner_error_ != NULL) {
				_g_free0 (motd_line);
				_g_object_unref0 (dis);
				_g_object_unref0 (motdfile);
				_g_free0 (motdpath);
				tmplist = (g_free (tmplist), NULL);
				goto __catch0_g_error;
			}
			_g_free0 (motd_line);
			motd_line = _tmp31_;
			_tmp34_ = motd_line;
			if (!(_tmp34_ != NULL)) {
				break;
			}
			_tmp35_ = motd_line;
			_tmp36_ = g_strdup (_tmp35_);
			self->motd = g_list_append (self->motd, _tmp36_);
		}
		_tmp38_ = self->priv->file;
		_tmp39_ = g_key_file_get_integer (_tmp38_, "ServerVariables", "ping_invertal", &_inner_error_);
		_tmp37_ = _tmp39_;
		if (_inner_error_ != NULL) {
			_g_free0 (motd_line);
			_g_object_unref0 (dis);
			_g_object_unref0 (motdfile);
			_g_free0 (motdpath);
			tmplist = (g_free (tmplist), NULL);
			goto __catch0_g_error;
		}
		self->ping_invertal = _tmp37_;
		_tmp41_ = self->priv->file;
		_tmp42_ = g_key_file_get_string (_tmp41_, "ServerVariables", "host_salt", &_inner_error_);
		_tmp40_ = _tmp42_;
		if (_inner_error_ != NULL) {
			_g_free0 (motd_line);
			_g_object_unref0 (dis);
			_g_object_unref0 (motdfile);
			_g_free0 (motdpath);
			tmplist = (g_free (tmplist), NULL);
			goto __catch0_g_error;
		}
		_g_free0 (self->salt);
		self->salt = _tmp40_;
		_g_free0 (motd_line);
		_g_object_unref0 (dis);
		_g_object_unref0 (motdfile);
		_g_free0 (motdpath);
		tmplist = (g_free (tmplist), NULL);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp43_ = NULL;
		GError* _tmp44_ = NULL;
		const gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		gchar* _tmp47_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp43_ = stdout;
		_tmp44_ = e;
		_tmp45_ = _tmp44_->message;
		_tmp46_ = g_strdup_printf ("Error Loading config file: %s\n", _tmp45_);
		_tmp47_ = _tmp46_;
		fprintf (_tmp43_, "%s", _tmp47_);
		_g_free0 (_tmp47_);
		self->config_error = TRUE;
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


yrcdyrcd_config* yrcd_yrcd_config_new (const gchar* filepath) {
	return yrcd_yrcd_config_construct (YRCD_TYPE_YRCD_CONFIG, filepath);
}


const gchar* yrcd_yrcd_config_get_sname (yrcdyrcd_config* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_sname;
	result = _tmp0_;
	return result;
}


void yrcd_yrcd_config_set_sname (yrcdyrcd_config* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_sname);
	self->priv->_sname = _tmp1_;
	g_object_notify ((GObject *) self, "sname");
}


static void yrcd_yrcd_config_class_init (yrcdyrcd_configClass * klass) {
	yrcd_yrcd_config_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (yrcdyrcd_configPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_yrcd_yrcd_config_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_yrcd_yrcd_config_set_property;
	G_OBJECT_CLASS (klass)->finalize = yrcd_yrcd_config_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), YRCD_YRCD_CONFIG_SNAME, g_param_spec_string ("sname", "sname", "sname", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void yrcd_yrcd_config_instance_init (yrcdyrcd_config * self) {
	GKeyFile* _tmp0_ = NULL;
	self->priv = YRCD_YRCD_CONFIG_GET_PRIVATE (self);
	_tmp0_ = g_key_file_new ();
	self->priv->file = _tmp0_;
	self->config_error = FALSE;
}


static void yrcd_yrcd_config_finalize (GObject* obj) {
	yrcdyrcd_config * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_config);
	_g_key_file_free0 (self->priv->file);
	_g_free0 (self->priv->_sname);
	_g_list_free0 (self->listen_ports);
	self->listen_ips = (_vala_array_free (self->listen_ips, self->listen_ips_length1, (GDestroyNotify) g_free), NULL);
	__g_list_free__g_free0_0 (self->motd);
	_g_free0 (self->salt);
	G_OBJECT_CLASS (yrcd_yrcd_config_parent_class)->finalize (obj);
}


GType yrcd_yrcd_config_get_type (void) {
	static volatile gsize yrcd_yrcd_config_type_id__volatile = 0;
	if (g_once_init_enter (&yrcd_yrcd_config_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (yrcdyrcd_configClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yrcd_yrcd_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (yrcdyrcd_config), 0, (GInstanceInitFunc) yrcd_yrcd_config_instance_init, NULL };
		GType yrcd_yrcd_config_type_id;
		yrcd_yrcd_config_type_id = g_type_register_static (G_TYPE_OBJECT, "yrcdyrcd_config", &g_define_type_info, 0);
		g_once_init_leave (&yrcd_yrcd_config_type_id__volatile, yrcd_yrcd_config_type_id);
	}
	return yrcd_yrcd_config_type_id__volatile;
}


static void _vala_yrcd_yrcd_config_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	yrcdyrcd_config * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_config);
	switch (property_id) {
		case YRCD_YRCD_CONFIG_SNAME:
		g_value_set_string (value, yrcd_yrcd_config_get_sname (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_yrcd_yrcd_config_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	yrcdyrcd_config * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, YRCD_TYPE_YRCD_CONFIG, yrcdyrcd_config);
	switch (property_id) {
		case YRCD_YRCD_CONFIG_SNAME:
		yrcd_yrcd_config_set_sname (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



