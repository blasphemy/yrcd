/* server.c generated by valac 0.24.0, the Vala compiler
 * generated from server.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define YRCD_TYPE_YRCD_SERVER (yrcd_yrcd_server_get_type ())
#define YRCD_YRCD_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_server))
#define YRCD_YRCD_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverClass))
#define YRCD_IS_YRCD_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_SERVER))
#define YRCD_IS_YRCD_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_SERVER))
#define YRCD_YRCD_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverClass))

typedef struct _yrcdyrcd_server yrcdyrcd_server;
typedef struct _yrcdyrcd_serverClass yrcdyrcd_serverClass;
typedef struct _yrcdyrcd_serverPrivate yrcdyrcd_serverPrivate;

#define YRCD_TYPE_YRCD_CHANNEL (yrcd_yrcd_channel_get_type ())
#define YRCD_YRCD_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_CHANNEL, yrcdyrcd_channel))
#define YRCD_YRCD_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_CHANNEL, yrcdyrcd_channelClass))
#define YRCD_IS_YRCD_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_CHANNEL))
#define YRCD_IS_YRCD_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_CHANNEL))
#define YRCD_YRCD_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_CHANNEL, yrcdyrcd_channelClass))

typedef struct _yrcdyrcd_channel yrcdyrcd_channel;
typedef struct _yrcdyrcd_channelClass yrcdyrcd_channelClass;

#define YRCD_TYPE_YRCD_NUMERIC_WRAPPER (yrcd_yrcd_numeric_wrapper_get_type ())
#define YRCD_YRCD_NUMERIC_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_NUMERIC_WRAPPER, yrcdyrcd_numeric_wrapper))
#define YRCD_YRCD_NUMERIC_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_NUMERIC_WRAPPER, yrcdyrcd_numeric_wrapperClass))
#define YRCD_IS_YRCD_NUMERIC_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_NUMERIC_WRAPPER))
#define YRCD_IS_YRCD_NUMERIC_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_NUMERIC_WRAPPER))
#define YRCD_YRCD_NUMERIC_WRAPPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_NUMERIC_WRAPPER, yrcdyrcd_numeric_wrapperClass))

typedef struct _yrcdyrcd_numeric_wrapper yrcdyrcd_numeric_wrapper;
typedef struct _yrcdyrcd_numeric_wrapperClass yrcdyrcd_numeric_wrapperClass;

#define YRCD_TYPE_YRCD_ROUTER (yrcd_yrcd_router_get_type ())
#define YRCD_YRCD_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_router))
#define YRCD_YRCD_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_routerClass))
#define YRCD_IS_YRCD_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_ROUTER))
#define YRCD_IS_YRCD_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_ROUTER))
#define YRCD_YRCD_ROUTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_routerClass))

typedef struct _yrcdyrcd_router yrcdyrcd_router;
typedef struct _yrcdyrcd_routerClass yrcdyrcd_routerClass;

#define YRCD_TYPE_YRCD_USER (yrcd_yrcd_user_get_type ())
#define YRCD_YRCD_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_USER, yrcdyrcd_user))
#define YRCD_YRCD_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_USER, yrcdyrcd_userClass))
#define YRCD_IS_YRCD_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_USER))
#define YRCD_IS_YRCD_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_USER))
#define YRCD_YRCD_USER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_USER, yrcdyrcd_userClass))

typedef struct _yrcdyrcd_user yrcdyrcd_user;
typedef struct _yrcdyrcd_userClass yrcdyrcd_userClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _YrcdYrcdServerProcessRequestData YrcdYrcdServerProcessRequestData;

struct _yrcdyrcd_server {
	GObject parent_instance;
	yrcdyrcd_serverPrivate * priv;
	GeeHashMap* channellist;
	gint64 epoch;
	gint max_users;
	yrcdyrcd_numeric_wrapper* numeric_wrapper;
};

struct _yrcdyrcd_serverClass {
	GObjectClass parent_class;
};

struct _yrcdyrcd_serverPrivate {
	GSocketService* ss;
	GMainLoop* loop;
	yrcdyrcd_router* router;
	GeeHashMap* userlist;
	gint user_counter;
	gint cid_counter;
};

struct _YrcdYrcdServerProcessRequestData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	yrcdyrcd_server* self;
	yrcdyrcd_user* user;
	yrcdyrcd_user* _tmp0_;
	GSocketConnection* _tmp1_;
	GSocketConnection* _tmp2_;
	gboolean _tmp3_;
	gchar* msg;
	yrcdyrcd_user* _tmp4_;
	GDataInputStream* _tmp5_;
	GDataInputStream* _tmp6_;
	gchar* _tmp7_;
	yrcdyrcd_router* _tmp8_;
	yrcdyrcd_user* _tmp9_;
	const gchar* _tmp10_;
	GError* e;
	GError* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GError * _inner_error_;
};


static gpointer yrcd_yrcd_server_parent_class = NULL;

GType yrcd_yrcd_server_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_channel_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_numeric_wrapper_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_router_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_user_get_type (void) G_GNUC_CONST;
#define YRCD_YRCD_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverPrivate))
enum  {
	YRCD_YRCD_SERVER_DUMMY_PROPERTY
};
yrcdyrcd_numeric_wrapper* yrcd_yrcd_numeric_wrapper_new (void);
yrcdyrcd_numeric_wrapper* yrcd_yrcd_numeric_wrapper_construct (GType object_type);
gint yrcd_yrcd_server_new_cid (yrcdyrcd_server* self);
gint yrcd_yrcd_server_new_userid (yrcdyrcd_server* self);
void yrcd_yrcd_server_log (yrcdyrcd_server* self, const gchar* msg);
yrcdyrcd_server* yrcd_yrcd_server_new (void);
yrcdyrcd_server* yrcd_yrcd_server_construct (GType object_type);
#define YRCD_YRCD_CONSTANTS_software "yrcd"
#define YRCD_YRCD_CONSTANTS_version "0.1"
void yrcd_yrcd_server_add_listeners (yrcdyrcd_server* self);
yrcdyrcd_router* yrcd_yrcd_router_new (yrcdyrcd_server* k);
yrcdyrcd_router* yrcd_yrcd_router_construct (GType object_type, yrcdyrcd_server* k);
static gboolean yrcd_yrcd_server_on_connection (yrcdyrcd_server* self, GSocketConnection* conn);
static gboolean _yrcd_yrcd_server_on_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self);
void yrcd_yrcd_server_remove_user (yrcdyrcd_server* self, gint id);
yrcdyrcd_user* yrcd_yrcd_user_new (GSocketConnection* conn, yrcdyrcd_server* _server);
yrcdyrcd_user* yrcd_yrcd_user_construct (GType object_type, GSocketConnection* conn, yrcdyrcd_server* _server);
gint yrcd_yrcd_user_get_id (yrcdyrcd_user* self);
static void yrcd_yrcd_server_process_request (yrcdyrcd_server* self, yrcdyrcd_user* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void yrcd_yrcd_server_process_request_finish (yrcdyrcd_server* self, GAsyncResult* _res_);
static void yrcd_yrcd_server_process_request_data_free (gpointer _data);
static gboolean yrcd_yrcd_server_process_request_co (YrcdYrcdServerProcessRequestData* _data_);
GSocketConnection* yrcd_yrcd_user_get_sock (yrcdyrcd_user* self);
GDataInputStream* yrcd_yrcd_user_get_dis (yrcdyrcd_user* self);
static void yrcd_yrcd_server_process_request_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void yrcd_yrcd_router_route (yrcdyrcd_router* self, yrcdyrcd_user* user, const gchar* msg);
gchar* yrcd_yrcd_server_ut_to_utc (yrcdyrcd_server* self, gint64 ut);
yrcdyrcd_user* yrcd_yrcd_server_get_user_by_nick (yrcdyrcd_server* self, const gchar* nicktocheck);
gboolean yrcd_yrcd_user_get_nick_set (yrcdyrcd_user* self);
const gchar* yrcd_yrcd_user_get_nick (yrcdyrcd_user* self);
yrcdyrcd_channel* yrcd_yrcd_server_get_channel_by_name (yrcdyrcd_server* self, const gchar* nametocheck);
const gchar* yrcd_yrcd_channel_get_name (yrcdyrcd_channel* self);
gboolean yrcd_yrcd_server_valid_chan_name (yrcdyrcd_server* self, const gchar* chan);
static void yrcd_yrcd_server_finalize (GObject* obj);

extern const gchar* YRCD_YRCD_CONSTANTS_listen_ips[1];
extern const guint16 YRCD_YRCD_CONSTANTS_listen_ports[2];
extern const gchar* YRCD_YRCD_CONSTANTS_chan_prefixes[2];
extern const gchar* YRCD_YRCD_CONSTANTS_chan_forbidden[5];

gint yrcd_yrcd_server_new_cid (yrcdyrcd_server* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->cid_counter;
	self->priv->cid_counter = _tmp0_ + 1;
	_tmp1_ = self->priv->cid_counter;
	result = _tmp1_;
	return result;
}


gint yrcd_yrcd_server_new_userid (yrcdyrcd_server* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->user_counter;
	self->priv->user_counter = _tmp0_ + 1;
	_tmp1_ = self->priv->user_counter;
	result = _tmp1_;
	return result;
}


void yrcd_yrcd_server_log (yrcdyrcd_server* self, const gchar* msg) {
	FILE* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (msg != NULL);
	_tmp0_ = stdout;
	_tmp1_ = msg;
	fprintf (_tmp0_, "LOG: %s\n", _tmp1_);
}


static gboolean _yrcd_yrcd_server_on_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self) {
	gboolean result;
	result = yrcd_yrcd_server_on_connection ((yrcdyrcd_server*) self, connection);
	return result;
}


yrcdyrcd_server* yrcd_yrcd_server_construct (GType object_type) {
	yrcdyrcd_server * self = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GDateTime* _tmp2_ = NULL;
	GDateTime* _tmp3_ = NULL;
	gint64 _tmp4_ = 0LL;
	yrcdyrcd_router* _tmp5_ = NULL;
	GSocketService* _tmp6_ = NULL;
	GSocketService* _tmp7_ = NULL;
	GMainLoop* _tmp8_ = NULL;
	self = (yrcdyrcd_server*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup_printf ("Initializing server: %s %s", YRCD_YRCD_CONSTANTS_software, YRCD_YRCD_CONSTANTS_version);
	_tmp1_ = _tmp0_;
	yrcd_yrcd_server_log (self, _tmp1_);
	_g_free0 (_tmp1_);
	_tmp2_ = g_date_time_new_now_utc ();
	_tmp3_ = _tmp2_;
	_tmp4_ = g_date_time_to_unix (_tmp3_);
	self->epoch = _tmp4_;
	_g_date_time_unref0 (_tmp3_);
	yrcd_yrcd_server_add_listeners (self);
	_tmp5_ = yrcd_yrcd_router_new (self);
	_g_object_unref0 (self->priv->router);
	self->priv->router = _tmp5_;
	_tmp6_ = self->priv->ss;
	g_signal_connect_object (_tmp6_, "incoming", (GCallback) _yrcd_yrcd_server_on_connection_g_socket_service_incoming, self, 0);
	_tmp7_ = self->priv->ss;
	g_socket_service_start (_tmp7_);
	_tmp8_ = self->priv->loop;
	g_main_loop_run (_tmp8_);
	return self;
}


yrcdyrcd_server* yrcd_yrcd_server_new (void) {
	return yrcd_yrcd_server_construct (YRCD_TYPE_YRCD_SERVER);
}


void yrcd_yrcd_server_remove_user (yrcdyrcd_server* self, gint id) {
	GeeHashMap* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->userlist;
	_tmp1_ = id;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp0_, (gpointer) ((gintptr) _tmp1_), NULL);
}


void yrcd_yrcd_server_add_listeners (yrcdyrcd_server* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		const gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = YRCD_YRCD_CONSTANTS_listen_ips;
		k_collection_length1 = G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ips);
		for (k_it = 0; k_it < G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ips); k_it = k_it + 1) {
			const gchar* k = NULL;
			k = k_collection[k_it];
			{
				{
					guint16* j_collection = NULL;
					gint j_collection_length1 = 0;
					gint _j_collection_size_ = 0;
					gint j_it = 0;
					j_collection = YRCD_YRCD_CONSTANTS_listen_ports;
					j_collection_length1 = G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ports);
					for (j_it = 0; j_it < G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ports); j_it = j_it + 1) {
						guint16 j = 0U;
						j = j_collection[j_it];
						{
							const gchar* _tmp0_ = NULL;
							guint16 _tmp1_ = 0U;
							gchar* _tmp2_ = NULL;
							gchar* _tmp3_ = NULL;
							GSocketAddress* serversock = NULL;
							GInetAddress* inetaddr = NULL;
							const gchar* _tmp4_ = NULL;
							GInetAddress* _tmp5_ = NULL;
							GSocketAddress* sockaddr = NULL;
							GInetAddress* _tmp6_ = NULL;
							guint16 _tmp7_ = 0U;
							GInetSocketAddress* _tmp8_ = NULL;
							_tmp0_ = k;
							_tmp1_ = j;
							_tmp2_ = g_strdup_printf ("Adding listener on IP: %s port %d", _tmp0_, (gint) _tmp1_);
							_tmp3_ = _tmp2_;
							yrcd_yrcd_server_log (self, _tmp3_);
							_g_free0 (_tmp3_);
							serversock = NULL;
							_tmp4_ = k;
							_tmp5_ = g_inet_address_new_from_string (_tmp4_);
							inetaddr = _tmp5_;
							_tmp6_ = inetaddr;
							_tmp7_ = j;
							_tmp8_ = (GInetSocketAddress*) g_inet_socket_address_new (_tmp6_, _tmp7_);
							sockaddr = (GSocketAddress*) _tmp8_;
							{
								GSocketService* _tmp9_ = NULL;
								GSocketAddress* _tmp10_ = NULL;
								GSocketService* _tmp11_ = NULL;
								GSocketAddress* _tmp12_ = NULL;
								_tmp9_ = self->priv->ss;
								_tmp10_ = sockaddr;
								_tmp11_ = self->priv->ss;
								g_socket_listener_add_address ((GSocketListener*) _tmp9_, _tmp10_, G_SOCKET_TYPE_STREAM, G_SOCKET_PROTOCOL_DEFAULT, (GObject*) _tmp11_, &_tmp12_, &_inner_error_);
								_g_object_unref0 (serversock);
								serversock = _tmp12_;
								if (_inner_error_ != NULL) {
									goto __catch0_g_error;
								}
							}
							goto __finally0;
							__catch0_g_error:
							{
								GError* e = NULL;
								GError* _tmp13_ = NULL;
								const gchar* _tmp14_ = NULL;
								gchar* _tmp15_ = NULL;
								gchar* _tmp16_ = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_tmp13_ = e;
								_tmp14_ = _tmp13_->message;
								_tmp15_ = g_strdup_printf ("Error opening socket: %s", _tmp14_);
								_tmp16_ = _tmp15_;
								yrcd_yrcd_server_log (self, _tmp16_);
								_g_free0 (_tmp16_);
								_g_error_free0 (e);
							}
							__finally0:
							if (_inner_error_ != NULL) {
								_g_object_unref0 (sockaddr);
								_g_object_unref0 (inetaddr);
								_g_object_unref0 (serversock);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_g_object_unref0 (sockaddr);
							_g_object_unref0 (inetaddr);
							_g_object_unref0 (serversock);
						}
					}
				}
			}
		}
	}
}


static gboolean yrcd_yrcd_server_on_connection (yrcdyrcd_server* self, GSocketConnection* conn) {
	gboolean result = FALSE;
	yrcdyrcd_user* user = NULL;
	GSocketConnection* _tmp0_ = NULL;
	yrcdyrcd_user* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	yrcdyrcd_user* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	yrcdyrcd_user* _tmp6_ = NULL;
	gint users = 0;
	GeeHashMap* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	yrcdyrcd_user* _tmp16_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (conn != NULL, FALSE);
	yrcd_yrcd_server_log (self, "Connection received, routing to process_request.");
	_tmp0_ = conn;
	_tmp1_ = yrcd_yrcd_user_new (_tmp0_, self);
	user = _tmp1_;
	_tmp2_ = self->priv->userlist;
	_tmp3_ = user;
	_tmp4_ = yrcd_yrcd_user_get_id (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = user;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp2_, (gpointer) ((gintptr) _tmp5_), _tmp6_);
	_tmp7_ = self->priv->userlist;
	_tmp8_ = gee_abstract_map_get_size ((GeeMap*) _tmp7_);
	_tmp9_ = _tmp8_;
	users = _tmp9_;
	_tmp10_ = users;
	_tmp11_ = self->max_users;
	if (_tmp10_ > _tmp11_) {
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		_tmp12_ = users;
		self->max_users = _tmp12_;
		_tmp13_ = self->max_users;
		_tmp14_ = g_strdup_printf ("New max amount of users: %d", _tmp13_);
		_tmp15_ = _tmp14_;
		yrcd_yrcd_server_log (self, _tmp15_);
		_g_free0 (_tmp15_);
	}
	_tmp16_ = user;
	yrcd_yrcd_server_process_request (self, _tmp16_, NULL, NULL);
	result = TRUE;
	_g_object_unref0 (user);
	return result;
}


static void yrcd_yrcd_server_process_request_data_free (gpointer _data) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->user);
	_g_object_unref0 (_data_->self);
	g_slice_free (YrcdYrcdServerProcessRequestData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void yrcd_yrcd_server_process_request (yrcdyrcd_server* self, yrcdyrcd_user* user, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	YrcdYrcdServerProcessRequestData* _data_;
	yrcdyrcd_server* _tmp0_ = NULL;
	yrcdyrcd_user* _tmp1_ = NULL;
	yrcdyrcd_user* _tmp2_ = NULL;
	_data_ = g_slice_new0 (YrcdYrcdServerProcessRequestData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, yrcd_yrcd_server_process_request);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, yrcd_yrcd_server_process_request_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = user;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->user);
	_data_->user = _tmp2_;
	yrcd_yrcd_server_process_request_co (_data_);
}


static void yrcd_yrcd_server_process_request_finish (yrcdyrcd_server* self, GAsyncResult* _res_) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void yrcd_yrcd_server_process_request_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	yrcd_yrcd_server_process_request_co (_data_);
}


static gboolean yrcd_yrcd_server_process_request_co (YrcdYrcdServerProcessRequestData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	yrcd_yrcd_server_log (_data_->self, "data streams open, entering main loop.");
	while (TRUE) {
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->user;
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = yrcd_yrcd_user_get_sock (_data_->_tmp0_);
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = _data_->_tmp1_;
		_data_->_tmp3_ = FALSE;
		_data_->_tmp3_ = g_socket_connection_is_connected (_data_->_tmp2_);
		if (!_data_->_tmp3_) {
			yrcd_yrcd_server_log (_data_->self, "Socket not connected...breaking");
			break;
		}
		{
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = _data_->user;
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = yrcd_yrcd_user_get_dis (_data_->_tmp4_);
			_data_->_tmp6_ = NULL;
			_data_->_tmp6_ = _data_->_tmp5_;
			_data_->_state_ = 1;
			g_data_input_stream_read_line_async (_data_->_tmp6_, G_PRIORITY_DEFAULT, NULL, yrcd_yrcd_server_process_request_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp7_ = NULL;
			_data_->_tmp7_ = g_data_input_stream_read_line_finish (_data_->_tmp6_, _data_->_res_, NULL, &_data_->_inner_error_);
			_data_->msg = _data_->_tmp7_;
			if (_data_->_inner_error_ != NULL) {
				goto __catch1_g_error;
			}
			_data_->_tmp8_ = NULL;
			_data_->_tmp8_ = _data_->self->priv->router;
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = _data_->user;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = _data_->msg;
			yrcd_yrcd_router_route (_data_->_tmp8_, _data_->_tmp9_, _data_->_tmp10_);
			_g_free0 (_data_->msg);
		}
		goto __finally1;
		__catch1_g_error:
		{
			_data_->e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = _data_->e;
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = _data_->_tmp11_->message;
			_data_->_tmp13_ = NULL;
			_data_->_tmp13_ = g_strdup_printf ("Error encountered in socket loop: %s", _data_->_tmp12_);
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->_tmp13_;
			yrcd_yrcd_server_log (_data_->self, _data_->_tmp14_);
			_g_free0 (_data_->_tmp14_);
			_g_error_free0 (_data_->e);
		}
		__finally1:
		if (_data_->_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gchar* g_date_time_to_string (GDateTime* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_date_time_format (self, "%FT%H:%M:%S%z");
	result = _tmp0_;
	return result;
}


gchar* yrcd_yrcd_server_ut_to_utc (yrcdyrcd_server* self, gint64 ut) {
	gchar* result = NULL;
	GDateTime* time = NULL;
	gint64 _tmp0_ = 0LL;
	GDateTime* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = ut;
	_tmp1_ = g_date_time_new_from_unix_utc (_tmp0_);
	time = _tmp1_;
	_tmp2_ = g_date_time_to_string (time);
	result = _tmp2_;
	_g_date_time_unref0 (time);
	return result;
}


yrcdyrcd_user* yrcd_yrcd_server_get_user_by_nick (yrcdyrcd_server* self, const gchar* nicktocheck) {
	yrcdyrcd_user* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (nicktocheck != NULL, NULL);
	{
		GeeHashMap* _k_list = NULL;
		GeeHashMap* _tmp0_ = NULL;
		GeeHashMap* _tmp1_ = NULL;
		gint _k_size = 0;
		GeeHashMap* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _k_index = 0;
		_tmp0_ = self->priv->userlist;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_k_list = _tmp1_;
		_tmp2_ = _k_list;
		_tmp3_ = gee_abstract_map_get_size ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_k_size = _tmp4_;
		_k_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			yrcdyrcd_user* k = NULL;
			GeeHashMap* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			yrcdyrcd_user* _tmp11_ = NULL;
			gboolean _tmp12_ = FALSE;
			gboolean _tmp13_ = FALSE;
			_tmp5_ = _k_index;
			_k_index = _tmp5_ + 1;
			_tmp6_ = _k_index;
			_tmp7_ = _k_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _k_list;
			_tmp9_ = _k_index;
			_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp8_, (gpointer) ((gintptr) _tmp9_));
			k = (yrcdyrcd_user*) _tmp10_;
			_tmp11_ = k;
			_tmp12_ = yrcd_yrcd_user_get_nick_set (_tmp11_);
			_tmp13_ = _tmp12_;
			if (_tmp13_) {
				yrcdyrcd_user* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				_tmp14_ = k;
				_tmp15_ = yrcd_yrcd_user_get_nick (_tmp14_);
				_tmp16_ = _tmp15_;
				_tmp17_ = nicktocheck;
				if (g_strcmp0 (_tmp16_, _tmp17_) == 0) {
					result = k;
					_g_object_unref0 (_k_list);
					return result;
				}
			}
			_g_object_unref0 (k);
		}
		_g_object_unref0 (_k_list);
	}
	result = NULL;
	return result;
}


yrcdyrcd_channel* yrcd_yrcd_server_get_channel_by_name (yrcdyrcd_server* self, const gchar* nametocheck) {
	yrcdyrcd_channel* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (nametocheck != NULL, NULL);
	{
		GeeHashMap* _k_list = NULL;
		GeeHashMap* _tmp0_ = NULL;
		GeeHashMap* _tmp1_ = NULL;
		gint _k_size = 0;
		GeeHashMap* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _k_index = 0;
		_tmp0_ = self->channellist;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_k_list = _tmp1_;
		_tmp2_ = _k_list;
		_tmp3_ = gee_abstract_map_get_size ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_k_size = _tmp4_;
		_k_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			yrcdyrcd_channel* k = NULL;
			GeeHashMap* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			yrcdyrcd_channel* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			_tmp5_ = _k_index;
			_k_index = _tmp5_ + 1;
			_tmp6_ = _k_index;
			_tmp7_ = _k_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _k_list;
			_tmp9_ = _k_index;
			_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp8_, (gpointer) ((gintptr) _tmp9_));
			k = (yrcdyrcd_channel*) _tmp10_;
			_tmp11_ = k;
			_tmp12_ = yrcd_yrcd_channel_get_name (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = nametocheck;
			if (g_strcmp0 (_tmp13_, _tmp14_) == 0) {
				result = k;
				_g_object_unref0 (_k_list);
				return result;
			}
			_g_object_unref0 (k);
		}
		_g_object_unref0 (_k_list);
	}
	result = NULL;
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


gboolean yrcd_yrcd_server_valid_chan_name (yrcdyrcd_server* self, const gchar* chan) {
	gboolean result = FALSE;
	gboolean valid = FALSE;
	gboolean has_prefix = FALSE;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (chan != NULL, FALSE);
	valid = TRUE;
	has_prefix = FALSE;
	{
		const gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = YRCD_YRCD_CONSTANTS_chan_prefixes;
		k_collection_length1 = G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_chan_prefixes);
		for (k_it = 0; k_it < G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_chan_prefixes); k_it = k_it + 1) {
			gchar* _tmp0_ = NULL;
			gchar* k = NULL;
			_tmp0_ = g_strdup (k_collection[k_it]);
			k = _tmp0_;
			{
				const gchar* _tmp1_ = NULL;
				const gchar* _tmp2_ = NULL;
				gboolean _tmp3_ = FALSE;
				_tmp1_ = chan;
				_tmp2_ = k;
				_tmp3_ = g_str_has_prefix (_tmp1_, _tmp2_);
				if (_tmp3_) {
					has_prefix = TRUE;
					_g_free0 (k);
					break;
				}
				_g_free0 (k);
			}
		}
	}
	{
		const gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = YRCD_YRCD_CONSTANTS_chan_forbidden;
		k_collection_length1 = G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_chan_forbidden);
		for (k_it = 0; k_it < G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_chan_forbidden); k_it = k_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* k = NULL;
			_tmp4_ = g_strdup (k_collection[k_it]);
			k = _tmp4_;
			{
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				_tmp5_ = chan;
				_tmp6_ = k;
				_tmp7_ = string_contains (_tmp5_, _tmp6_);
				if (_tmp7_) {
					valid = FALSE;
					_g_free0 (k);
					break;
				}
				_g_free0 (k);
			}
		}
	}
	_tmp9_ = has_prefix;
	if (_tmp9_) {
		gboolean _tmp10_ = FALSE;
		_tmp10_ = valid;
		_tmp8_ = _tmp10_;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		valid = TRUE;
	} else {
		valid = FALSE;
	}
	result = TRUE;
	return result;
}


static void yrcd_yrcd_server_class_init (yrcdyrcd_serverClass * klass) {
	yrcd_yrcd_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (yrcdyrcd_serverPrivate));
	G_OBJECT_CLASS (klass)->finalize = yrcd_yrcd_server_finalize;
}


static void yrcd_yrcd_server_instance_init (yrcdyrcd_server * self) {
	GSocketService* _tmp0_ = NULL;
	GMainLoop* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	GeeHashMap* _tmp3_ = NULL;
	yrcdyrcd_numeric_wrapper* _tmp4_ = NULL;
	self->priv = YRCD_YRCD_SERVER_GET_PRIVATE (self);
	_tmp0_ = g_socket_service_new ();
	self->priv->ss = _tmp0_;
	_tmp1_ = g_main_loop_new (NULL, FALSE);
	self->priv->loop = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, YRCD_TYPE_YRCD_USER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->userlist = _tmp2_;
	_tmp3_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, YRCD_TYPE_YRCD_CHANNEL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->channellist = _tmp3_;
	self->priv->user_counter = 0;
	self->priv->cid_counter = 0;
	self->max_users = 0;
	_tmp4_ = yrcd_yrcd_numeric_wrapper_new ();
	self->numeric_wrapper = _tmp4_;
}


static void yrcd_yrcd_server_finalize (GObject* obj) {
	yrcdyrcd_server * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YRCD_TYPE_YRCD_SERVER, yrcdyrcd_server);
	_g_object_unref0 (self->priv->ss);
	_g_main_loop_unref0 (self->priv->loop);
	_g_object_unref0 (self->priv->router);
	_g_object_unref0 (self->priv->userlist);
	_g_object_unref0 (self->channellist);
	_g_object_unref0 (self->numeric_wrapper);
	G_OBJECT_CLASS (yrcd_yrcd_server_parent_class)->finalize (obj);
}


GType yrcd_yrcd_server_get_type (void) {
	static volatile gsize yrcd_yrcd_server_type_id__volatile = 0;
	if (g_once_init_enter (&yrcd_yrcd_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (yrcdyrcd_serverClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yrcd_yrcd_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (yrcdyrcd_server), 0, (GInstanceInitFunc) yrcd_yrcd_server_instance_init, NULL };
		GType yrcd_yrcd_server_type_id;
		yrcd_yrcd_server_type_id = g_type_register_static (G_TYPE_OBJECT, "yrcdyrcd_server", &g_define_type_info, 0);
		g_once_init_leave (&yrcd_yrcd_server_type_id__volatile, yrcd_yrcd_server_type_id);
	}
	return yrcd_yrcd_server_type_id__volatile;
}



