/* server.c generated by valac 0.25.1, the Vala compiler
 * generated from server.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define YRCD_TYPE_SERVER (yrcd_server_get_type ())
#define YRCD_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_SERVER, yrcdServer))
#define YRCD_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_SERVER, yrcdServerClass))
#define YRCD_IS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_SERVER))
#define YRCD_IS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_SERVER))
#define YRCD_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_SERVER, yrcdServerClass))

typedef struct _yrcdServer yrcdServer;
typedef struct _yrcdServerClass yrcdServerClass;
typedef struct _yrcdServerPrivate yrcdServerPrivate;

#define YRCD_TYPE_USER (yrcd_user_get_type ())
#define YRCD_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_USER, yrcdUser))
#define YRCD_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_USER, yrcdUserClass))
#define YRCD_IS_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_USER))
#define YRCD_IS_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_USER))
#define YRCD_USER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_USER, yrcdUserClass))

typedef struct _yrcdUser yrcdUser;
typedef struct _yrcdUserClass yrcdUserClass;

#define YRCD_TYPE_CHANNEL (yrcd_channel_get_type ())
#define YRCD_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_CHANNEL, yrcdChannel))
#define YRCD_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_CHANNEL, yrcdChannelClass))
#define YRCD_IS_CHANNEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_CHANNEL))
#define YRCD_IS_CHANNEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_CHANNEL))
#define YRCD_CHANNEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_CHANNEL, yrcdChannelClass))

typedef struct _yrcdChannel yrcdChannel;
typedef struct _yrcdChannelClass yrcdChannelClass;

#define YRCD_TYPE_NUMERIC_WRAPPER (yrcd_numeric_wrapper_get_type ())
#define YRCD_NUMERIC_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_NUMERIC_WRAPPER, yrcdNumericWrapper))
#define YRCD_NUMERIC_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_NUMERIC_WRAPPER, yrcdNumericWrapperClass))
#define YRCD_IS_NUMERIC_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_NUMERIC_WRAPPER))
#define YRCD_IS_NUMERIC_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_NUMERIC_WRAPPER))
#define YRCD_NUMERIC_WRAPPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_NUMERIC_WRAPPER, yrcdNumericWrapperClass))

typedef struct _yrcdNumericWrapper yrcdNumericWrapper;
typedef struct _yrcdNumericWrapperClass yrcdNumericWrapperClass;

#define YRCD_TYPE_CONFIG (yrcd_config_get_type ())
#define YRCD_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_CONFIG, yrcdConfig))
#define YRCD_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_CONFIG, yrcdConfigClass))
#define YRCD_IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_CONFIG))
#define YRCD_IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_CONFIG))
#define YRCD_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_CONFIG, yrcdConfigClass))

typedef struct _yrcdConfig yrcdConfig;
typedef struct _yrcdConfigClass yrcdConfigClass;

#define YRCD_TYPE_ROUTER (yrcd_router_get_type ())
#define YRCD_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_ROUTER, yrcdRouter))
#define YRCD_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_ROUTER, yrcdRouterClass))
#define YRCD_IS_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_ROUTER))
#define YRCD_IS_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_ROUTER))
#define YRCD_ROUTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_ROUTER, yrcdRouterClass))

typedef struct _yrcdRouter yrcdRouter;
typedef struct _yrcdRouterClass yrcdRouterClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
typedef struct _yrcdConfigPrivate yrcdConfigPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

struct _yrcdServer {
	GObject parent_instance;
	yrcdServerPrivate * priv;
	GeeHashMap* userlist;
	GeeHashMap* channellist;
	gint64 epoch;
	gint max_users;
	yrcdNumericWrapper* numeric_wrapper;
	yrcdConfig* config;
};

struct _yrcdServerClass {
	GObjectClass parent_class;
};

struct _yrcdServerPrivate {
	GSocketService* ss;
	yrcdRouter* router;
	gint user_counter;
};

struct _yrcdConfig {
	GObject parent_instance;
	yrcdConfigPrivate * priv;
	GList* listen_ports;
	gchar** listen_ips;
	gint listen_ips_length1;
	GList* motd;
	gint ping_invertal;
	gint max_users;
	gboolean config_error;
	gboolean cloaking;
	gchar* salt;
};

struct _yrcdConfigClass {
	GObjectClass parent_class;
};


static gpointer yrcd_server_parent_class = NULL;

GType yrcd_server_get_type (void) G_GNUC_CONST;
GType yrcd_user_get_type (void) G_GNUC_CONST;
GType yrcd_channel_get_type (void) G_GNUC_CONST;
GType yrcd_numeric_wrapper_get_type (void) G_GNUC_CONST;
GType yrcd_config_get_type (void) G_GNUC_CONST;
GType yrcd_router_get_type (void) G_GNUC_CONST;
#define YRCD_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), YRCD_TYPE_SERVER, yrcdServerPrivate))
enum  {
	YRCD_SERVER_DUMMY_PROPERTY
};
yrcdNumericWrapper* yrcd_numeric_wrapper_new (void);
yrcdNumericWrapper* yrcd_numeric_wrapper_construct (GType object_type);
gint yrcd_server_new_userid (yrcdServer* self);
void yrcd_server_log (yrcdServer* self, const gchar* msg);
yrcdServer* yrcd_server_new (yrcdConfig* _config);
yrcdServer* yrcd_server_construct (GType object_type, yrcdConfig* _config);
#define YRCD_CONSTANTS_software "yrcd"
#define YRCD_CONSTANTS_version "0.2"
void yrcd_server_add_listeners (yrcdServer* self);
yrcdRouter* yrcd_router_new (yrcdServer* k);
yrcdRouter* yrcd_router_construct (GType object_type, yrcdServer* k);
gboolean yrcd_server_accept_connection (yrcdServer* self, GSocketConnection* conn);
static gboolean _yrcd_server_accept_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self);
void yrcd_server_remove_user (yrcdServer* self, gint id);
void yrcd_server_remove_channel (yrcdServer* self, const gchar* name);
void yrcd_router_process_user (yrcdRouter* self, GSocketConnection* conn, GAsyncReadyCallback _callback_, gpointer _user_data_);
void yrcd_router_process_user_finish (yrcdRouter* self, GAsyncResult* _res_);
gchar* yrcd_server_ut_to_utc (yrcdServer* self, gint64 ut);
yrcdUser* yrcd_server_get_user_by_nick (yrcdServer* self, const gchar* nicktocheck);
const gchar* yrcd_user_get_nick (yrcdUser* self);
yrcdChannel* yrcd_server_get_channel_by_name (yrcdServer* self, const gchar* nametocheck);
yrcdChannel* yrcd_channel_new (yrcdServer* _server, const gchar* _name);
yrcdChannel* yrcd_channel_construct (GType object_type, yrcdServer* _server, const gchar* _name);
const gchar* yrcd_channel_get_name (yrcdChannel* self);
void yrcd_server_send_to_many (yrcdServer* self, GList* users, const gchar* msg, gint p);
void yrcd_user_send_line (yrcdUser* self, const gchar* msg, gint p);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void yrcd_server_finalize (GObject* obj);


gint yrcd_server_new_userid (yrcdServer* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->user_counter;
	self->priv->user_counter = _tmp0_ + 1;
	_tmp1_ = self->priv->user_counter;
	result = _tmp1_;
	return result;
}


void yrcd_server_log (yrcdServer* self, const gchar* msg) {
	FILE* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (msg != NULL);
	_tmp0_ = stdout;
	_tmp1_ = msg;
	fprintf (_tmp0_, "LOG: %s\n", _tmp1_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _yrcd_server_accept_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self) {
	gboolean result;
	result = yrcd_server_accept_connection ((yrcdServer*) self, connection);
	return result;
}


yrcdServer* yrcd_server_construct (GType object_type, yrcdConfig* _config) {
	yrcdServer * self = NULL;
	yrcdConfig* _tmp0_ = NULL;
	yrcdConfig* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GDateTime* _tmp4_ = NULL;
	GDateTime* _tmp5_ = NULL;
	gint64 _tmp6_ = 0LL;
	yrcdRouter* _tmp7_ = NULL;
	GeeHashMap* _tmp8_ = NULL;
	GSocketService* _tmp9_ = NULL;
	GSocketService* _tmp10_ = NULL;
	g_return_val_if_fail (_config != NULL, NULL);
	self = (yrcdServer*) g_object_new (object_type, NULL);
	_tmp0_ = _config;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->config);
	self->config = _tmp1_;
	_tmp2_ = g_strdup_printf ("Initializing server: %s %s", YRCD_CONSTANTS_software, YRCD_CONSTANTS_version);
	_tmp3_ = _tmp2_;
	yrcd_server_log (self, _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = g_date_time_new_now_utc ();
	_tmp5_ = _tmp4_;
	_tmp6_ = g_date_time_to_unix (_tmp5_);
	self->epoch = _tmp6_;
	_g_date_time_unref0 (_tmp5_);
	yrcd_server_add_listeners (self);
	_tmp7_ = yrcd_router_new (self);
	_g_object_unref0 (self->priv->router);
	self->priv->router = _tmp7_;
	_tmp8_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, YRCD_TYPE_CHANNEL, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->channellist);
	self->channellist = _tmp8_;
	_tmp9_ = self->priv->ss;
	g_signal_connect_object (_tmp9_, "incoming", (GCallback) _yrcd_server_accept_connection_g_socket_service_incoming, self, 0);
	_tmp10_ = self->priv->ss;
	g_socket_service_start (_tmp10_);
	return self;
}


yrcdServer* yrcd_server_new (yrcdConfig* _config) {
	return yrcd_server_construct (YRCD_TYPE_SERVER, _config);
}


void yrcd_server_remove_user (yrcdServer* self, gint id) {
	GeeHashMap* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->userlist;
	_tmp1_ = id;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp0_, (gpointer) ((gintptr) _tmp1_), NULL);
}


void yrcd_server_remove_channel (yrcdServer* self, const gchar* name) {
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->channellist;
	_tmp1_ = name;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp0_, _tmp1_, NULL);
}


void yrcd_server_add_listeners (yrcdServer* self) {
	yrcdConfig* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->config;
	_tmp1_ = _tmp0_->listen_ips;
	_tmp1__length1 = _tmp0_->listen_ips_length1;
	{
		gchar** k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = _tmp1_;
		k_collection_length1 = _tmp1__length1;
		for (k_it = 0; k_it < _tmp1__length1; k_it = k_it + 1) {
			gchar* _tmp2_ = NULL;
			gchar* k = NULL;
			_tmp2_ = g_strdup (k_collection[k_it]);
			k = _tmp2_;
			{
				yrcdConfig* _tmp3_ = NULL;
				GList* _tmp4_ = NULL;
				_tmp3_ = self->config;
				_tmp4_ = _tmp3_->listen_ports;
				{
					GList* j_collection = NULL;
					GList* j_it = NULL;
					j_collection = _tmp4_;
					for (j_it = j_collection; j_it != NULL; j_it = j_it->next) {
						guint16 j = 0U;
						j = (guint16) ((guintptr) j_it->data);
						{
							const gchar* _tmp5_ = NULL;
							guint16 _tmp6_ = 0U;
							gchar* _tmp7_ = NULL;
							gchar* _tmp8_ = NULL;
							GSocketAddress* serversock = NULL;
							GInetAddress* inetaddr = NULL;
							const gchar* _tmp9_ = NULL;
							GInetAddress* _tmp10_ = NULL;
							GSocketAddress* sockaddr = NULL;
							GInetAddress* _tmp11_ = NULL;
							guint16 _tmp12_ = 0U;
							GInetSocketAddress* _tmp13_ = NULL;
							_tmp5_ = k;
							_tmp6_ = j;
							_tmp7_ = g_strdup_printf ("Adding listener on IP: %s port %d", _tmp5_, (gint) _tmp6_);
							_tmp8_ = _tmp7_;
							yrcd_server_log (self, _tmp8_);
							_g_free0 (_tmp8_);
							serversock = NULL;
							_tmp9_ = k;
							_tmp10_ = g_inet_address_new_from_string (_tmp9_);
							inetaddr = _tmp10_;
							_tmp11_ = inetaddr;
							_tmp12_ = j;
							_tmp13_ = (GInetSocketAddress*) g_inet_socket_address_new (_tmp11_, _tmp12_);
							sockaddr = (GSocketAddress*) _tmp13_;
							{
								GSocketService* _tmp14_ = NULL;
								GSocketAddress* _tmp15_ = NULL;
								GSocketService* _tmp16_ = NULL;
								GSocketAddress* _tmp17_ = NULL;
								_tmp14_ = self->priv->ss;
								_tmp15_ = sockaddr;
								_tmp16_ = self->priv->ss;
								g_socket_listener_add_address ((GSocketListener*) _tmp14_, _tmp15_, G_SOCKET_TYPE_STREAM, G_SOCKET_PROTOCOL_DEFAULT, (GObject*) _tmp16_, &_tmp17_, &_inner_error_);
								_g_object_unref0 (serversock);
								serversock = _tmp17_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									goto __catch3_g_error;
								}
							}
							goto __finally3;
							__catch3_g_error:
							{
								GError* e = NULL;
								GError* _tmp18_ = NULL;
								const gchar* _tmp19_ = NULL;
								gchar* _tmp20_ = NULL;
								gchar* _tmp21_ = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_tmp18_ = e;
								_tmp19_ = _tmp18_->message;
								_tmp20_ = g_strdup_printf ("Error opening socket: %s", _tmp19_);
								_tmp21_ = _tmp20_;
								yrcd_server_log (self, _tmp21_);
								_g_free0 (_tmp21_);
								_g_error_free0 (e);
							}
							__finally3:
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								_g_object_unref0 (sockaddr);
								_g_object_unref0 (inetaddr);
								_g_object_unref0 (serversock);
								_g_free0 (k);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_g_object_unref0 (sockaddr);
							_g_object_unref0 (inetaddr);
							_g_object_unref0 (serversock);
						}
					}
				}
				_g_free0 (k);
			}
		}
	}
}


gboolean yrcd_server_accept_connection (yrcdServer* self, GSocketConnection* conn) {
	gboolean result = FALSE;
	yrcdRouter* _tmp0_ = NULL;
	GSocketConnection* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (conn != NULL, FALSE);
	_tmp0_ = self->priv->router;
	_tmp1_ = conn;
	yrcd_router_process_user (_tmp0_, _tmp1_, NULL, NULL);
	result = TRUE;
	return result;
}


static gchar* g_date_time_to_string (GDateTime* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_date_time_format (self, "%FT%H:%M:%S%z");
	result = _tmp0_;
	return result;
}


gchar* yrcd_server_ut_to_utc (yrcdServer* self, gint64 ut) {
	gchar* result = NULL;
	GDateTime* time = NULL;
	gint64 _tmp0_ = 0LL;
	GDateTime* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = ut;
	_tmp1_ = g_date_time_new_from_unix_utc (_tmp0_);
	time = _tmp1_;
	_tmp2_ = g_date_time_to_string (time);
	result = _tmp2_;
	_g_date_time_unref0 (time);
	return result;
}


yrcdUser* yrcd_server_get_user_by_nick (yrcdServer* self, const gchar* nicktocheck) {
	yrcdUser* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (nicktocheck != NULL, NULL);
	{
		GeeHashMap* _k_list = NULL;
		GeeHashMap* _tmp0_ = NULL;
		GeeHashMap* _tmp1_ = NULL;
		gint _k_size = 0;
		GeeHashMap* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _k_index = 0;
		_tmp0_ = self->userlist;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_k_list = _tmp1_;
		_tmp2_ = _k_list;
		_tmp3_ = gee_abstract_map_get_size ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_k_size = _tmp4_;
		_k_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			yrcdUser* k = NULL;
			GeeHashMap* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			yrcdUser* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_ = NULL;
			gboolean _tmp19_ = FALSE;
			_tmp5_ = _k_index;
			_k_index = _tmp5_ + 1;
			_tmp6_ = _k_index;
			_tmp7_ = _k_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _k_list;
			_tmp9_ = _k_index;
			_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp8_, (gpointer) ((gintptr) _tmp9_));
			k = (yrcdUser*) _tmp10_;
			_tmp11_ = k;
			_tmp12_ = yrcd_user_get_nick (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = g_utf8_strdown (_tmp13_, (gssize) (-1));
			_tmp15_ = _tmp14_;
			_tmp16_ = nicktocheck;
			_tmp17_ = g_utf8_strdown (_tmp16_, (gssize) (-1));
			_tmp18_ = _tmp17_;
			_tmp19_ = g_strcmp0 (_tmp15_, _tmp18_) == 0;
			_g_free0 (_tmp18_);
			_g_free0 (_tmp15_);
			if (_tmp19_) {
				result = k;
				_g_object_unref0 (_k_list);
				return result;
			}
			_g_object_unref0 (k);
		}
		_g_object_unref0 (_k_list);
	}
	result = NULL;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


yrcdChannel* yrcd_server_get_channel_by_name (yrcdServer* self, const gchar* nametocheck) {
	yrcdChannel* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GeeHashMap* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gpointer _tmp6_ = NULL;
	yrcdChannel* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	const gchar* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	yrcdChannel* chan = NULL;
	const gchar* _tmp20_ = NULL;
	yrcdChannel* _tmp21_ = NULL;
	GeeHashMap* _tmp22_ = NULL;
	yrcdChannel* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	gchar* _tmp27_ = NULL;
	yrcdChannel* _tmp28_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (nametocheck != NULL, NULL);
	_tmp0_ = nametocheck;
	_tmp1_ = string_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("Looking for channel ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	yrcd_server_log (self, _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = self->channellist;
	_tmp5_ = nametocheck;
	_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp4_, _tmp5_);
	_tmp7_ = (yrcdChannel*) _tmp6_;
	_tmp8_ = _tmp7_ != NULL;
	_g_object_unref0 (_tmp7_);
	if (_tmp8_) {
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		GeeHashMap* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gpointer _tmp15_ = NULL;
		_tmp9_ = nametocheck;
		_tmp10_ = string_to_string (_tmp9_);
		_tmp11_ = g_strconcat ("channel ", _tmp10_, "  found", NULL);
		_tmp12_ = _tmp11_;
		yrcd_server_log (self, _tmp12_);
		_g_free0 (_tmp12_);
		_tmp13_ = self->channellist;
		_tmp14_ = nametocheck;
		_tmp15_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp13_, _tmp14_);
		result = (yrcdChannel*) _tmp15_;
		return result;
	}
	_tmp16_ = nametocheck;
	_tmp17_ = string_to_string (_tmp16_);
	_tmp18_ = g_strconcat ("Channel ", _tmp17_, " not found, creating it", NULL);
	_tmp19_ = _tmp18_;
	yrcd_server_log (self, _tmp19_);
	_g_free0 (_tmp19_);
	_tmp20_ = nametocheck;
	_tmp21_ = yrcd_channel_new (self, _tmp20_);
	chan = _tmp21_;
	_tmp22_ = self->channellist;
	_tmp23_ = chan;
	_tmp24_ = yrcd_channel_get_name (_tmp23_);
	_tmp25_ = _tmp24_;
	_tmp26_ = g_utf8_strdown (_tmp25_, (gssize) (-1));
	_tmp27_ = _tmp26_;
	_tmp28_ = chan;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp22_, _tmp27_, _tmp28_);
	_g_free0 (_tmp27_);
	result = chan;
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


void yrcd_server_send_to_many (yrcdServer* self, GList* users, const gchar* msg, gint p) {
	GList* final = NULL;
	GList* _tmp0_ = NULL;
	GList* _tmp9_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (msg != NULL);
	final = NULL;
	_tmp0_ = users;
	{
		GList* k_collection = NULL;
		GList* k_it = NULL;
		k_collection = _tmp0_;
		for (k_it = k_collection; k_it != NULL; k_it = k_it->next) {
			yrcdUser* _tmp1_ = NULL;
			yrcdUser* k = NULL;
			_tmp1_ = _g_object_ref0 ((yrcdUser*) k_it->data);
			k = _tmp1_;
			{
				gboolean dup = FALSE;
				GList* _tmp2_ = NULL;
				gboolean _tmp6_ = FALSE;
				dup = FALSE;
				_tmp2_ = final;
				{
					GList* j_collection = NULL;
					GList* j_it = NULL;
					j_collection = _tmp2_;
					for (j_it = j_collection; j_it != NULL; j_it = j_it->next) {
						yrcdUser* _tmp3_ = NULL;
						yrcdUser* j = NULL;
						_tmp3_ = _g_object_ref0 ((yrcdUser*) j_it->data);
						j = _tmp3_;
						{
							yrcdUser* _tmp4_ = NULL;
							yrcdUser* _tmp5_ = NULL;
							_tmp4_ = k;
							_tmp5_ = j;
							if (_tmp4_ == _tmp5_) {
								dup = TRUE;
							}
							_g_object_unref0 (j);
						}
					}
				}
				_tmp6_ = dup;
				if (!_tmp6_) {
					yrcdUser* _tmp7_ = NULL;
					yrcdUser* _tmp8_ = NULL;
					_tmp7_ = k;
					_tmp8_ = _g_object_ref0 (_tmp7_);
					final = g_list_append (final, _tmp8_);
				}
				_g_object_unref0 (k);
			}
		}
	}
	_tmp9_ = final;
	{
		GList* k_collection = NULL;
		GList* k_it = NULL;
		k_collection = _tmp9_;
		for (k_it = k_collection; k_it != NULL; k_it = k_it->next) {
			yrcdUser* _tmp10_ = NULL;
			yrcdUser* k = NULL;
			_tmp10_ = _g_object_ref0 ((yrcdUser*) k_it->data);
			k = _tmp10_;
			{
				yrcdUser* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				_tmp11_ = k;
				_tmp12_ = msg;
				_tmp13_ = p;
				yrcd_user_send_line (_tmp11_, _tmp12_, _tmp13_);
				_g_object_unref0 (k);
			}
		}
	}
	__g_list_free__g_object_unref0_0 (final);
}


static void yrcd_server_class_init (yrcdServerClass * klass) {
	yrcd_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (yrcdServerPrivate));
	G_OBJECT_CLASS (klass)->finalize = yrcd_server_finalize;
}


static void yrcd_server_instance_init (yrcdServer * self) {
	GSocketService* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	yrcdNumericWrapper* _tmp2_ = NULL;
	self->priv = YRCD_SERVER_GET_PRIVATE (self);
	_tmp0_ = g_socket_service_new ();
	self->priv->ss = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, YRCD_TYPE_USER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->userlist = _tmp1_;
	self->priv->user_counter = 0;
	self->max_users = 0;
	_tmp2_ = yrcd_numeric_wrapper_new ();
	self->numeric_wrapper = _tmp2_;
}


static void yrcd_server_finalize (GObject* obj) {
	yrcdServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YRCD_TYPE_SERVER, yrcdServer);
	_g_object_unref0 (self->priv->ss);
	_g_object_unref0 (self->priv->router);
	_g_object_unref0 (self->userlist);
	_g_object_unref0 (self->channellist);
	_g_object_unref0 (self->numeric_wrapper);
	_g_object_unref0 (self->config);
	G_OBJECT_CLASS (yrcd_server_parent_class)->finalize (obj);
}


GType yrcd_server_get_type (void) {
	static volatile gsize yrcd_server_type_id__volatile = 0;
	if (g_once_init_enter (&yrcd_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (yrcdServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yrcd_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (yrcdServer), 0, (GInstanceInitFunc) yrcd_server_instance_init, NULL };
		GType yrcd_server_type_id;
		yrcd_server_type_id = g_type_register_static (G_TYPE_OBJECT, "yrcdServer", &g_define_type_info, 0);
		g_once_init_leave (&yrcd_server_type_id__volatile, yrcd_server_type_id);
	}
	return yrcd_server_type_id__volatile;
}



