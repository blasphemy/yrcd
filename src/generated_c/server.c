/* server.c generated by valac 0.24.0, the Vala compiler
 * generated from server.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define YRCD_TYPE_YRCD_SERVER (yrcd_yrcd_server_get_type ())
#define YRCD_YRCD_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_server))
#define YRCD_YRCD_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverClass))
#define YRCD_IS_YRCD_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_SERVER))
#define YRCD_IS_YRCD_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_SERVER))
#define YRCD_YRCD_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverClass))

typedef struct _yrcdyrcd_server yrcdyrcd_server;
typedef struct _yrcdyrcd_serverClass yrcdyrcd_serverClass;
typedef struct _yrcdyrcd_serverPrivate yrcdyrcd_serverPrivate;

#define YRCD_TYPE_YRCD_ROUTER (yrcd_yrcd_router_get_type ())
#define YRCD_YRCD_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_router))
#define YRCD_YRCD_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_routerClass))
#define YRCD_IS_YRCD_ROUTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_ROUTER))
#define YRCD_IS_YRCD_ROUTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_ROUTER))
#define YRCD_YRCD_ROUTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_ROUTER, yrcdyrcd_routerClass))

typedef struct _yrcdyrcd_router yrcdyrcd_router;
typedef struct _yrcdyrcd_routerClass yrcdyrcd_routerClass;

#define YRCD_TYPE_YRCD_USER (yrcd_yrcd_user_get_type ())
#define YRCD_YRCD_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YRCD_TYPE_YRCD_USER, yrcdyrcd_user))
#define YRCD_YRCD_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YRCD_TYPE_YRCD_USER, yrcdyrcd_userClass))
#define YRCD_IS_YRCD_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YRCD_TYPE_YRCD_USER))
#define YRCD_IS_YRCD_USER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YRCD_TYPE_YRCD_USER))
#define YRCD_YRCD_USER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YRCD_TYPE_YRCD_USER, yrcdyrcd_userClass))

typedef struct _yrcdyrcd_user yrcdyrcd_user;
typedef struct _yrcdyrcd_userClass yrcdyrcd_userClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _YrcdYrcdServerProcessRequestData YrcdYrcdServerProcessRequestData;

struct _yrcdyrcd_server {
	GObject parent_instance;
	yrcdyrcd_serverPrivate * priv;
};

struct _yrcdyrcd_serverClass {
	GObjectClass parent_class;
};

struct _yrcdyrcd_serverPrivate {
	GSocketService* ss;
	GMainLoop* loop;
	yrcdyrcd_router* router;
	GeeHashMap* userlist;
	gint user_counter;
};

struct _YrcdYrcdServerProcessRequestData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	yrcdyrcd_server* self;
	yrcdyrcd_user* user;
	yrcdyrcd_user* _tmp0_;
	GSocketConnection* _tmp1_;
	GSocketConnection* _tmp2_;
	gboolean _tmp3_;
	gchar* msg;
	yrcdyrcd_user* _tmp4_;
	GDataInputStream* _tmp5_;
	GDataInputStream* _tmp6_;
	gchar* _tmp7_;
	yrcdyrcd_router* _tmp8_;
	yrcdyrcd_user* _tmp9_;
	const gchar* _tmp10_;
	GError* e;
	GError* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	GError * _inner_error_;
};


static gpointer yrcd_yrcd_server_parent_class = NULL;

GType yrcd_yrcd_server_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_router_get_type (void) G_GNUC_CONST;
GType yrcd_yrcd_user_get_type (void) G_GNUC_CONST;
#define YRCD_YRCD_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), YRCD_TYPE_YRCD_SERVER, yrcdyrcd_serverPrivate))
enum  {
	YRCD_YRCD_SERVER_DUMMY_PROPERTY
};
yrcdyrcd_router* yrcd_yrcd_router_new (void);
yrcdyrcd_router* yrcd_yrcd_router_construct (GType object_type);
gint yrcd_yrcd_server_new_userid (yrcdyrcd_server* self);
void yrcd_yrcd_server_log (yrcdyrcd_server* self, const gchar* msg);
yrcdyrcd_server* yrcd_yrcd_server_new (void);
yrcdyrcd_server* yrcd_yrcd_server_construct (GType object_type);
#define YRCD_YRCD_CONSTANTS_software "yrcd"
#define YRCD_YRCD_CONSTANTS_version "0.1"
void yrcd_yrcd_server_add_port (yrcdyrcd_server* self, guint16 port);
static gboolean yrcd_yrcd_server_on_connection (yrcdyrcd_server* self, GSocketConnection* conn);
static gboolean _yrcd_yrcd_server_on_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self);
yrcdyrcd_user* yrcd_yrcd_user_new (GSocketConnection* conn, yrcdyrcd_server* _server);
yrcdyrcd_user* yrcd_yrcd_user_construct (GType object_type, GSocketConnection* conn, yrcdyrcd_server* _server);
gint yrcd_yrcd_user_get_id (yrcdyrcd_user* self);
static void yrcd_yrcd_server_process_request (yrcdyrcd_server* self, yrcdyrcd_user* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void yrcd_yrcd_server_process_request_finish (yrcdyrcd_server* self, GAsyncResult* _res_);
static void yrcd_yrcd_server_process_request_data_free (gpointer _data);
static gboolean yrcd_yrcd_server_process_request_co (YrcdYrcdServerProcessRequestData* _data_);
GSocketConnection* yrcd_yrcd_user_get_sock (yrcdyrcd_user* self);
GDataInputStream* yrcd_yrcd_user_get_dis (yrcdyrcd_user* self);
static void yrcd_yrcd_server_process_request_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void yrcd_yrcd_router_route (yrcdyrcd_router* self, yrcdyrcd_user* user, const gchar* msg);
static void yrcd_yrcd_server_finalize (GObject* obj);

extern const guint16 YRCD_YRCD_CONSTANTS_listen_ports[2];

gint yrcd_yrcd_server_new_userid (yrcdyrcd_server* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->user_counter;
	self->priv->user_counter = _tmp0_ + 1;
	_tmp1_ = self->priv->user_counter;
	result = _tmp1_;
	return result;
}


void yrcd_yrcd_server_log (yrcdyrcd_server* self, const gchar* msg) {
	FILE* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (msg != NULL);
	_tmp0_ = stdout;
	_tmp1_ = msg;
	fprintf (_tmp0_, "LOG: %s\n", _tmp1_);
}


static gboolean _yrcd_yrcd_server_on_connection_g_socket_service_incoming (GSocketService* _sender, GSocketConnection* connection, GObject* source_object, gpointer self) {
	gboolean result;
	result = yrcd_yrcd_server_on_connection ((yrcdyrcd_server*) self, connection);
	return result;
}


yrcdyrcd_server* yrcd_yrcd_server_construct (GType object_type) {
	yrcdyrcd_server * self = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GSocketService* _tmp3_ = NULL;
	GSocketService* _tmp4_ = NULL;
	GMainLoop* _tmp5_ = NULL;
	self = (yrcdyrcd_server*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup_printf ("Initializing server: %s %s", YRCD_YRCD_CONSTANTS_software, YRCD_YRCD_CONSTANTS_version);
	_tmp1_ = _tmp0_;
	yrcd_yrcd_server_log (self, _tmp1_);
	_g_free0 (_tmp1_);
	{
		guint16* k_collection = NULL;
		gint k_collection_length1 = 0;
		gint _k_collection_size_ = 0;
		gint k_it = 0;
		k_collection = YRCD_YRCD_CONSTANTS_listen_ports;
		k_collection_length1 = G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ports);
		for (k_it = 0; k_it < G_N_ELEMENTS (YRCD_YRCD_CONSTANTS_listen_ports); k_it = k_it + 1) {
			guint16 k = 0U;
			k = k_collection[k_it];
			{
				guint16 _tmp2_ = 0U;
				_tmp2_ = k;
				yrcd_yrcd_server_add_port (self, _tmp2_);
			}
		}
	}
	_tmp3_ = self->priv->ss;
	g_signal_connect_object (_tmp3_, "incoming", (GCallback) _yrcd_yrcd_server_on_connection_g_socket_service_incoming, self, 0);
	_tmp4_ = self->priv->ss;
	g_socket_service_start (_tmp4_);
	_tmp5_ = self->priv->loop;
	g_main_loop_run (_tmp5_);
	return self;
}


yrcdyrcd_server* yrcd_yrcd_server_new (void) {
	return yrcd_yrcd_server_construct (YRCD_TYPE_YRCD_SERVER);
}


void yrcd_yrcd_server_add_port (yrcdyrcd_server* self, guint16 port) {
	guint16 _tmp0_ = 0U;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = port;
	_tmp1_ = g_strdup_printf ("attempting to add port %d", (gint) _tmp0_);
	_tmp2_ = _tmp1_;
	yrcd_yrcd_server_log (self, _tmp2_);
	_g_free0 (_tmp2_);
	{
		GSocketService* _tmp3_ = NULL;
		guint16 _tmp4_ = 0U;
		guint16 _tmp5_ = 0U;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp3_ = self->priv->ss;
		_tmp4_ = port;
		g_socket_listener_add_inet_port ((GSocketListener*) _tmp3_, _tmp4_, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp5_ = port;
		_tmp6_ = g_strdup_printf ("port %d successfully added", (gint) _tmp5_);
		_tmp7_ = _tmp6_;
		yrcd_yrcd_server_log (self, _tmp7_);
		_g_free0 (_tmp7_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		_tmp10_ = g_strdup_printf ("Add Port error: %s", _tmp9_);
		_tmp11_ = _tmp10_;
		yrcd_yrcd_server_log (self, _tmp11_);
		_g_free0 (_tmp11_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gboolean yrcd_yrcd_server_on_connection (yrcdyrcd_server* self, GSocketConnection* conn) {
	gboolean result = FALSE;
	yrcdyrcd_user* user = NULL;
	GSocketConnection* _tmp0_ = NULL;
	yrcdyrcd_user* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (conn != NULL, FALSE);
	yrcd_yrcd_server_log (self, "Connection received, routing to process_request.");
	_tmp0_ = conn;
	_tmp1_ = yrcd_yrcd_user_new (_tmp0_, self);
	user = _tmp1_;
	_tmp2_ = self->priv->userlist;
	_tmp3_ = yrcd_yrcd_user_get_id (user);
	_tmp4_ = _tmp3_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp2_, (gpointer) ((gintptr) _tmp4_), user);
	yrcd_yrcd_server_process_request (self, user, NULL, NULL);
	result = TRUE;
	_g_object_unref0 (user);
	return result;
}


static void yrcd_yrcd_server_process_request_data_free (gpointer _data) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->user);
	_g_object_unref0 (_data_->self);
	g_slice_free (YrcdYrcdServerProcessRequestData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void yrcd_yrcd_server_process_request (yrcdyrcd_server* self, yrcdyrcd_user* user, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	YrcdYrcdServerProcessRequestData* _data_;
	yrcdyrcd_server* _tmp0_ = NULL;
	yrcdyrcd_user* _tmp1_ = NULL;
	yrcdyrcd_user* _tmp2_ = NULL;
	_data_ = g_slice_new0 (YrcdYrcdServerProcessRequestData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, yrcd_yrcd_server_process_request);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, yrcd_yrcd_server_process_request_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = user;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->user);
	_data_->user = _tmp2_;
	yrcd_yrcd_server_process_request_co (_data_);
}


static void yrcd_yrcd_server_process_request_finish (yrcdyrcd_server* self, GAsyncResult* _res_) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void yrcd_yrcd_server_process_request_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	YrcdYrcdServerProcessRequestData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	yrcd_yrcd_server_process_request_co (_data_);
}


static gboolean yrcd_yrcd_server_process_request_co (YrcdYrcdServerProcessRequestData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	yrcd_yrcd_server_log (_data_->self, "data streams open, entering main loop.");
	while (TRUE) {
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->user;
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = yrcd_yrcd_user_get_sock (_data_->_tmp0_);
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = _data_->_tmp1_;
		_data_->_tmp3_ = FALSE;
		_data_->_tmp3_ = g_socket_connection_is_connected (_data_->_tmp2_);
		if (!_data_->_tmp3_) {
			yrcd_yrcd_server_log (_data_->self, "Socket not connected...breaking");
			break;
		}
		{
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = _data_->user;
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = yrcd_yrcd_user_get_dis (_data_->_tmp4_);
			_data_->_tmp6_ = NULL;
			_data_->_tmp6_ = _data_->_tmp5_;
			_data_->_state_ = 1;
			g_data_input_stream_read_line_async (_data_->_tmp6_, G_PRIORITY_DEFAULT, NULL, yrcd_yrcd_server_process_request_ready, _data_);
			return FALSE;
			_state_1:
			_data_->_tmp7_ = NULL;
			_data_->_tmp7_ = g_data_input_stream_read_line_finish (_data_->_tmp6_, _data_->_res_, NULL, &_data_->_inner_error_);
			_data_->msg = _data_->_tmp7_;
			if (_data_->_inner_error_ != NULL) {
				goto __catch1_g_error;
			}
			_data_->_tmp8_ = NULL;
			_data_->_tmp8_ = _data_->self->priv->router;
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = _data_->user;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = _data_->msg;
			yrcd_yrcd_router_route (_data_->_tmp8_, _data_->_tmp9_, _data_->_tmp10_);
			_g_free0 (_data_->msg);
		}
		goto __finally1;
		__catch1_g_error:
		{
			_data_->e = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = _data_->e;
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = _data_->_tmp11_->message;
			_data_->_tmp13_ = NULL;
			_data_->_tmp13_ = g_strdup_printf ("Error encountered in socket loop: %s", _data_->_tmp12_);
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->_tmp13_;
			yrcd_yrcd_server_log (_data_->self, _data_->_tmp14_);
			_g_free0 (_data_->_tmp14_);
			_g_error_free0 (_data_->e);
		}
		__finally1:
		if (_data_->_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void yrcd_yrcd_server_class_init (yrcdyrcd_serverClass * klass) {
	yrcd_yrcd_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (yrcdyrcd_serverPrivate));
	G_OBJECT_CLASS (klass)->finalize = yrcd_yrcd_server_finalize;
}


static void yrcd_yrcd_server_instance_init (yrcdyrcd_server * self) {
	GSocketService* _tmp0_ = NULL;
	GMainLoop* _tmp1_ = NULL;
	yrcdyrcd_router* _tmp2_ = NULL;
	GeeHashMap* _tmp3_ = NULL;
	self->priv = YRCD_YRCD_SERVER_GET_PRIVATE (self);
	_tmp0_ = g_socket_service_new ();
	self->priv->ss = _tmp0_;
	_tmp1_ = g_main_loop_new (NULL, FALSE);
	self->priv->loop = _tmp1_;
	_tmp2_ = yrcd_yrcd_router_new ();
	self->priv->router = _tmp2_;
	_tmp3_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, YRCD_TYPE_YRCD_USER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->userlist = _tmp3_;
	self->priv->user_counter = 0;
}


static void yrcd_yrcd_server_finalize (GObject* obj) {
	yrcdyrcd_server * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YRCD_TYPE_YRCD_SERVER, yrcdyrcd_server);
	_g_object_unref0 (self->priv->ss);
	_g_main_loop_unref0 (self->priv->loop);
	_g_object_unref0 (self->priv->router);
	_g_object_unref0 (self->priv->userlist);
	G_OBJECT_CLASS (yrcd_yrcd_server_parent_class)->finalize (obj);
}


GType yrcd_yrcd_server_get_type (void) {
	static volatile gsize yrcd_yrcd_server_type_id__volatile = 0;
	if (g_once_init_enter (&yrcd_yrcd_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (yrcdyrcd_serverClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yrcd_yrcd_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (yrcdyrcd_server), 0, (GInstanceInitFunc) yrcd_yrcd_server_instance_init, NULL };
		GType yrcd_yrcd_server_type_id;
		yrcd_yrcd_server_type_id = g_type_register_static (G_TYPE_OBJECT, "yrcdyrcd_server", &g_define_type_info, 0);
		g_once_init_leave (&yrcd_yrcd_server_type_id__volatile, yrcd_yrcd_server_type_id);
	}
	return yrcd_yrcd_server_type_id__volatile;
}



